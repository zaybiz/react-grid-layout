'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var Draggable = require('react-draggable');
var PureRenderMixin = require('react/lib/ReactComponentWithPureRenderMixin');
var assign = require('object-assign');
var cloneWithProps = require('react/lib/cloneWithProps');

var Resizable = module.exports = React.createClass({
  displayName: 'Resizable',
  mixins: [PureRenderMixin],

  propTypes: {
    // Require that one and only one child be present.
    children: React.PropTypes.element.isRequired,
    // Functions
    onResizeStop: React.PropTypes.func,
    onResizeStart: React.PropTypes.func,
    onResize: React.PropTypes.func,

    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    // If you change this, be sure to update your css
    handleSize: React.PropTypes.array,
    // These will be passed wholesale to react-draggable
    draggableOpts: React.PropTypes.object
  },

  getDefaultProps: function getDefaultProps() {
    return {
      handleSize: [20, 20]
    };
  },

  minConstraints: function minConstraints() {
    return parseConstraints(this.props.minConstraints, this.props.handleSize) || this.props.handleSize;
  },

  maxConstraints: function maxConstraints() {
    return parseConstraints(this.props.maxConstraints, this.props.handleSize);
  },

  /**
   * Wrapper around drag events to provide more useful data.
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */
  resizeHandler: function resizeHandler(handlerName) {
    var me = this;
    return function (e, _ref) {
      var element = _ref.element;
      var position = _ref.position;

      me.props[handlerName] && me.props[handlerName](e, { element: element, size: calcWH(position, me.props.handleSize) });
    };
  },

  render: function render() {
    var p = this.props;

    // What we're doing here is getting the child of this element, and cloning it with this element's props.
    // We are then defining its children as:
    // Its original children (resizable's child's children), and
    // A draggable handle.
    return cloneWithProps(p.children, assign({}, p, {
      children: [p.children.props.children, React.createElement(
        Draggable,
        _extends({}, p.draggableOpts, {
          start: { x: p.width - 20, y: p.height - 20 },
          moveOnStartChange: true,
          onStop: this.resizeHandler('onResizeStop'),
          onStart: this.resizeHandler('onResizeStart'),
          onDrag: this.resizeHandler('onResize'),
          minConstraints: this.minConstraints(),
          maxConstraints: this.maxConstraints()
        }),
        React.createElement('span', { className: 'react-resizable-handle' })
      )]
    }));
  }
});

/**
 * Parse left and top coordinates; we have to add the handle size to get the full picture.
 * @param  {Number} options.left Left coordinate.
 * @param  {Number} options.top  Top coordinate.
 * @param  {Array}  handleSize   Handle data.
 * @return {Object}              Coordinates
 */
function calcWH(_ref, handleSize) {
  var left = _ref.left;
  var top = _ref.top;

  return { width: left + handleSize[0], height: top + handleSize[1] };
}

/**
 * Constraints must be subtracted by the size of the handle to work properly.
 * This has a side-effect of effectively limiting the minimum size to the handleSize,
 * which IMO is fine.
 * @param  {Array} constraints Constraints array.
 * @param  {Array} handleSize  Handle size array.
 * @return {Array}             Transformed constraints.
 */
function parseConstraints(constraints, handleSize) {
  if (!constraints) {
    return;
  }return constraints.map(function (c, i) {
    return c - handleSize[i];
  });
}